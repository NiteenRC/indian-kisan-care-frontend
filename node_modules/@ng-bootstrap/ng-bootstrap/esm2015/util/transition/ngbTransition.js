import { EMPTY, fromEvent, of, race, Subject, timer } from 'rxjs';
import { endWith, filter, takeUntil } from 'rxjs/operators';
import { getTransitionDurationMs } from './util';
import { environment } from '../../environment';
import { reflow } from '../util';
const noopFn = () => { };
const ɵ0 = noopFn;
const { transitionTimerDelayMs } = environment;
const runningTransitions = new Map();
export const ngbRunTransition = (element, startFn, options) => {
    // Getting initial context from options
    let context = options.context || {};
    // Checking if there are already running transitions on the given element.
    const running = runningTransitions.get(element);
    if (running) {
        switch (options.runningTransition) {
            // If there is one running and we want for it to 'continue' to run, we have to cancel the new one.
            // We're not emitting any values, but simply completing the observable (EMPTY).
            case 'continue':
                return EMPTY;
            // If there is one running and we want for it to 'stop', we have to complete the running one.
            // We're simply completing the running one and not emitting any values and merging newly provided context
            // with the one coming from currently running transition.
            case 'stop':
                running.transition$.complete();
                context = Object.assign(running.context, context);
                runningTransitions.delete(element);
        }
    }
    // A reflow is required here, to be sure that everything is ready,
    // Without reflow, the transition will not be started for some widgets, at initialization time
    reflow(element);
    const endFn = startFn(element, context) || noopFn;
    // If 'prefer-reduced-motion' is enabled, the 'transition' will be set to 'none'.
    // If animations are disabled, we have to emit a value and complete the observable
    // In this case we have to call the end function, but can finish immediately by emitting a value,
    // completing the observable and executing end functions synchronously.
    if (!options.animation || window.getComputedStyle(element).transitionProperty === 'none') {
        endFn();
        return of(undefined);
    }
    // Starting a new transition
    const transition$ = new Subject();
    const stop$ = transition$.pipe(endWith(true));
    runningTransitions.set(element, { transition$, context });
    const transitionDurationMs = getTransitionDurationMs(element);
    // 1. We have to both listen for the 'transitionend' event and have a 'just-in-case' timer,
    // because 'transitionend' event might not be fired in some browsers, if the transitioning
    // element becomes invisible (ex. when scrolling, making browser tab inactive, etc.). The timer
    // guarantees, that we'll release the DOM element and complete 'ngbRunTransition'.
    // 2. We need to filter transition end events, because they might bubble from shorter transitions
    // on inner DOM elements. We're only interested in the transition on the 'element' itself.
    const transitionEnd$ = fromEvent(element, 'transitionend').pipe(takeUntil(stop$), filter(({ target }) => target === element));
    const timer$ = timer(transitionDurationMs + transitionTimerDelayMs).pipe(takeUntil(stop$));
    race(timer$, transitionEnd$).pipe(takeUntil(stop$)).subscribe(() => {
        runningTransitions.delete(element);
        endFn();
        transition$.next();
        transition$.complete();
    });
    return transition$.asObservable();
};
export { ɵ0 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmdiVHJhbnNpdGlvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy91dGlsL3RyYW5zaXRpb24vbmdiVHJhbnNpdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUMsS0FBSyxFQUFFLFNBQVMsRUFBYyxFQUFFLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUMsTUFBTSxNQUFNLENBQUM7QUFDNUUsT0FBTyxFQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFDLE1BQU0sZ0JBQWdCLENBQUM7QUFDMUQsT0FBTyxFQUFDLHVCQUF1QixFQUFDLE1BQU0sUUFBUSxDQUFDO0FBQy9DLE9BQU8sRUFBQyxXQUFXLEVBQUMsTUFBTSxtQkFBbUIsQ0FBQztBQUM5QyxPQUFPLEVBQUMsTUFBTSxFQUFDLE1BQU0sU0FBUyxDQUFDO0FBZ0IvQixNQUFNLE1BQU0sR0FBdUIsR0FBRyxFQUFFLEdBQUUsQ0FBQyxDQUFDOztBQUU1QyxNQUFNLEVBQUMsc0JBQXNCLEVBQUMsR0FBRyxXQUFXLENBQUM7QUFDN0MsTUFBTSxrQkFBa0IsR0FBRyxJQUFJLEdBQUcsRUFBc0MsQ0FBQztBQUV6RSxNQUFNLENBQUMsTUFBTSxnQkFBZ0IsR0FDekIsQ0FBSSxPQUFvQixFQUFFLE9BQWdDLEVBQUUsT0FBZ0MsRUFDbEUsRUFBRTtJQUV0Qix1Q0FBdUM7SUFDdkMsSUFBSSxPQUFPLEdBQUcsT0FBTyxDQUFDLE9BQU8sSUFBTyxFQUFFLENBQUM7SUFFdkMsMEVBQTBFO0lBQzFFLE1BQU0sT0FBTyxHQUFHLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNoRCxJQUFJLE9BQU8sRUFBRTtRQUNYLFFBQVEsT0FBTyxDQUFDLGlCQUFpQixFQUFFO1lBQ2pDLGtHQUFrRztZQUNsRywrRUFBK0U7WUFDL0UsS0FBSyxVQUFVO2dCQUNiLE9BQU8sS0FBSyxDQUFDO1lBQ2YsNkZBQTZGO1lBQzdGLHlHQUF5RztZQUN6Ryx5REFBeUQ7WUFDekQsS0FBSyxNQUFNO2dCQUNULE9BQU8sQ0FBQyxXQUFXLENBQUMsUUFBUSxFQUFFLENBQUM7Z0JBQy9CLE9BQU8sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7Z0JBQ2xELGtCQUFrQixDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUN0QztLQUNGO0lBRUQsa0VBQWtFO0lBQ2xFLDhGQUE4RjtJQUM5RixNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7SUFFaEIsTUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsSUFBSSxNQUFNLENBQUM7SUFFbEQsaUZBQWlGO0lBQ2pGLGtGQUFrRjtJQUNsRixpR0FBaUc7SUFDakcsdUVBQXVFO0lBQ3ZFLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxJQUFJLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsQ0FBQyxrQkFBa0IsS0FBSyxNQUFNLEVBQUU7UUFDeEYsS0FBSyxFQUFFLENBQUM7UUFDUixPQUFPLEVBQUUsQ0FBQyxTQUFTLENBQUMsQ0FBQztLQUN0QjtJQUVELDRCQUE0QjtJQUM1QixNQUFNLFdBQVcsR0FBRyxJQUFJLE9BQU8sRUFBTyxDQUFDO0lBQ3ZDLE1BQU0sS0FBSyxHQUFHLFdBQVcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDOUMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxFQUFDLFdBQVcsRUFBRSxPQUFPLEVBQUMsQ0FBQyxDQUFDO0lBRXhELE1BQU0sb0JBQW9CLEdBQUcsdUJBQXVCLENBQUMsT0FBTyxDQUFDLENBQUM7SUFFOUQsMkZBQTJGO0lBQzNGLDBGQUEwRjtJQUMxRiwrRkFBK0Y7SUFDL0Ysa0ZBQWtGO0lBQ2xGLGlHQUFpRztJQUNqRywwRkFBMEY7SUFDMUYsTUFBTSxjQUFjLEdBQ2hCLFNBQVMsQ0FBQyxPQUFPLEVBQUUsZUFBZSxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxFQUFDLE1BQU0sRUFBQyxFQUFFLEVBQUUsQ0FBQyxNQUFNLEtBQUssT0FBTyxDQUFDLENBQUMsQ0FBQztJQUN6RyxNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsb0JBQW9CLEdBQUcsc0JBQXNCLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFFM0YsSUFBSSxDQUFDLE1BQU0sRUFBRSxjQUFjLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLEdBQUcsRUFBRTtRQUNqRSxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDbkMsS0FBSyxFQUFFLENBQUM7UUFDUixXQUFXLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDbkIsV0FBVyxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQ3pCLENBQUMsQ0FBQyxDQUFDO0lBRUgsT0FBTyxXQUFXLENBQUMsWUFBWSxFQUFFLENBQUM7QUFDcEMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtFTVBUWSwgZnJvbUV2ZW50LCBPYnNlcnZhYmxlLCBvZiwgcmFjZSwgU3ViamVjdCwgdGltZXJ9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtlbmRXaXRoLCBmaWx0ZXIsIHRha2VVbnRpbH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHtnZXRUcmFuc2l0aW9uRHVyYXRpb25Nc30gZnJvbSAnLi91dGlsJztcbmltcG9ydCB7ZW52aXJvbm1lbnR9IGZyb20gJy4uLy4uL2Vudmlyb25tZW50JztcbmltcG9ydCB7cmVmbG93fSBmcm9tICcuLi91dGlsJztcblxuZXhwb3J0IHR5cGUgTmdiVHJhbnNpdGlvblN0YXJ0Rm48VCA9IGFueT4gPSAoZWxlbWVudDogSFRNTEVsZW1lbnQsIGNvbnRleHQ6IFQpID0+IE5nYlRyYW5zaXRpb25FbmRGbiB8IHZvaWQ7XG5leHBvcnQgdHlwZSBOZ2JUcmFuc2l0aW9uRW5kRm4gPSAoKSA9PiB2b2lkO1xuXG5leHBvcnQgaW50ZXJmYWNlIE5nYlRyYW5zaXRpb25PcHRpb25zPFQ+IHtcbiAgYW5pbWF0aW9uOiBib29sZWFuO1xuICBydW5uaW5nVHJhbnNpdGlvbjogJ2NvbnRpbnVlJyB8ICdzdG9wJztcbiAgY29udGV4dD86IFQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTmdiVHJhbnNpdGlvbkN0eDxUPiB7XG4gIHRyYW5zaXRpb24kOiBTdWJqZWN0PGFueT47XG4gIGNvbnRleHQ6IFQ7XG59XG5cbmNvbnN0IG5vb3BGbjogTmdiVHJhbnNpdGlvbkVuZEZuID0gKCkgPT4ge307XG5cbmNvbnN0IHt0cmFuc2l0aW9uVGltZXJEZWxheU1zfSA9IGVudmlyb25tZW50O1xuY29uc3QgcnVubmluZ1RyYW5zaXRpb25zID0gbmV3IE1hcDxIVE1MRWxlbWVudCwgTmdiVHJhbnNpdGlvbkN0eDxhbnk+PigpO1xuXG5leHBvcnQgY29uc3QgbmdiUnVuVHJhbnNpdGlvbiA9XG4gICAgPFQ+KGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBzdGFydEZuOiBOZ2JUcmFuc2l0aW9uU3RhcnRGbjxUPiwgb3B0aW9uczogTmdiVHJhbnNpdGlvbk9wdGlvbnM8VD4pOlxuICAgICAgICBPYnNlcnZhYmxlPHVuZGVmaW5lZD4gPT4ge1xuXG4gICAgICAgICAgLy8gR2V0dGluZyBpbml0aWFsIGNvbnRleHQgZnJvbSBvcHRpb25zXG4gICAgICAgICAgbGV0IGNvbnRleHQgPSBvcHRpb25zLmNvbnRleHQgfHwgPFQ+e307XG5cbiAgICAgICAgICAvLyBDaGVja2luZyBpZiB0aGVyZSBhcmUgYWxyZWFkeSBydW5uaW5nIHRyYW5zaXRpb25zIG9uIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAgICAgIGNvbnN0IHJ1bm5pbmcgPSBydW5uaW5nVHJhbnNpdGlvbnMuZ2V0KGVsZW1lbnQpO1xuICAgICAgICAgIGlmIChydW5uaW5nKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKG9wdGlvbnMucnVubmluZ1RyYW5zaXRpb24pIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgb25lIHJ1bm5pbmcgYW5kIHdlIHdhbnQgZm9yIGl0IHRvICdjb250aW51ZScgdG8gcnVuLCB3ZSBoYXZlIHRvIGNhbmNlbCB0aGUgbmV3IG9uZS5cbiAgICAgICAgICAgICAgLy8gV2UncmUgbm90IGVtaXR0aW5nIGFueSB2YWx1ZXMsIGJ1dCBzaW1wbHkgY29tcGxldGluZyB0aGUgb2JzZXJ2YWJsZSAoRU1QVFkpLlxuICAgICAgICAgICAgICBjYXNlICdjb250aW51ZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIEVNUFRZO1xuICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBvbmUgcnVubmluZyBhbmQgd2Ugd2FudCBmb3IgaXQgdG8gJ3N0b3AnLCB3ZSBoYXZlIHRvIGNvbXBsZXRlIHRoZSBydW5uaW5nIG9uZS5cbiAgICAgICAgICAgICAgLy8gV2UncmUgc2ltcGx5IGNvbXBsZXRpbmcgdGhlIHJ1bm5pbmcgb25lIGFuZCBub3QgZW1pdHRpbmcgYW55IHZhbHVlcyBhbmQgbWVyZ2luZyBuZXdseSBwcm92aWRlZCBjb250ZXh0XG4gICAgICAgICAgICAgIC8vIHdpdGggdGhlIG9uZSBjb21pbmcgZnJvbSBjdXJyZW50bHkgcnVubmluZyB0cmFuc2l0aW9uLlxuICAgICAgICAgICAgICBjYXNlICdzdG9wJzpcbiAgICAgICAgICAgICAgICBydW5uaW5nLnRyYW5zaXRpb24kLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgY29udGV4dCA9IE9iamVjdC5hc3NpZ24ocnVubmluZy5jb250ZXh0LCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBydW5uaW5nVHJhbnNpdGlvbnMuZGVsZXRlKGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEEgcmVmbG93IGlzIHJlcXVpcmVkIGhlcmUsIHRvIGJlIHN1cmUgdGhhdCBldmVyeXRoaW5nIGlzIHJlYWR5LFxuICAgICAgICAgIC8vIFdpdGhvdXQgcmVmbG93LCB0aGUgdHJhbnNpdGlvbiB3aWxsIG5vdCBiZSBzdGFydGVkIGZvciBzb21lIHdpZGdldHMsIGF0IGluaXRpYWxpemF0aW9uIHRpbWVcbiAgICAgICAgICByZWZsb3coZWxlbWVudCk7XG5cbiAgICAgICAgICBjb25zdCBlbmRGbiA9IHN0YXJ0Rm4oZWxlbWVudCwgY29udGV4dCkgfHwgbm9vcEZuO1xuXG4gICAgICAgICAgLy8gSWYgJ3ByZWZlci1yZWR1Y2VkLW1vdGlvbicgaXMgZW5hYmxlZCwgdGhlICd0cmFuc2l0aW9uJyB3aWxsIGJlIHNldCB0byAnbm9uZScuXG4gICAgICAgICAgLy8gSWYgYW5pbWF0aW9ucyBhcmUgZGlzYWJsZWQsIHdlIGhhdmUgdG8gZW1pdCBhIHZhbHVlIGFuZCBjb21wbGV0ZSB0aGUgb2JzZXJ2YWJsZVxuICAgICAgICAgIC8vIEluIHRoaXMgY2FzZSB3ZSBoYXZlIHRvIGNhbGwgdGhlIGVuZCBmdW5jdGlvbiwgYnV0IGNhbiBmaW5pc2ggaW1tZWRpYXRlbHkgYnkgZW1pdHRpbmcgYSB2YWx1ZSxcbiAgICAgICAgICAvLyBjb21wbGV0aW5nIHRoZSBvYnNlcnZhYmxlIGFuZCBleGVjdXRpbmcgZW5kIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5LlxuICAgICAgICAgIGlmICghb3B0aW9ucy5hbmltYXRpb24gfHwgd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkudHJhbnNpdGlvblByb3BlcnR5ID09PSAnbm9uZScpIHtcbiAgICAgICAgICAgIGVuZEZuKCk7XG4gICAgICAgICAgICByZXR1cm4gb2YodW5kZWZpbmVkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTdGFydGluZyBhIG5ldyB0cmFuc2l0aW9uXG4gICAgICAgICAgY29uc3QgdHJhbnNpdGlvbiQgPSBuZXcgU3ViamVjdDxhbnk+KCk7XG4gICAgICAgICAgY29uc3Qgc3RvcCQgPSB0cmFuc2l0aW9uJC5waXBlKGVuZFdpdGgodHJ1ZSkpO1xuICAgICAgICAgIHJ1bm5pbmdUcmFuc2l0aW9ucy5zZXQoZWxlbWVudCwge3RyYW5zaXRpb24kLCBjb250ZXh0fSk7XG5cbiAgICAgICAgICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb25NcyA9IGdldFRyYW5zaXRpb25EdXJhdGlvbk1zKGVsZW1lbnQpO1xuXG4gICAgICAgICAgLy8gMS4gV2UgaGF2ZSB0byBib3RoIGxpc3RlbiBmb3IgdGhlICd0cmFuc2l0aW9uZW5kJyBldmVudCBhbmQgaGF2ZSBhICdqdXN0LWluLWNhc2UnIHRpbWVyLFxuICAgICAgICAgIC8vIGJlY2F1c2UgJ3RyYW5zaXRpb25lbmQnIGV2ZW50IG1pZ2h0IG5vdCBiZSBmaXJlZCBpbiBzb21lIGJyb3dzZXJzLCBpZiB0aGUgdHJhbnNpdGlvbmluZ1xuICAgICAgICAgIC8vIGVsZW1lbnQgYmVjb21lcyBpbnZpc2libGUgKGV4LiB3aGVuIHNjcm9sbGluZywgbWFraW5nIGJyb3dzZXIgdGFiIGluYWN0aXZlLCBldGMuKS4gVGhlIHRpbWVyXG4gICAgICAgICAgLy8gZ3VhcmFudGVlcywgdGhhdCB3ZSdsbCByZWxlYXNlIHRoZSBET00gZWxlbWVudCBhbmQgY29tcGxldGUgJ25nYlJ1blRyYW5zaXRpb24nLlxuICAgICAgICAgIC8vIDIuIFdlIG5lZWQgdG8gZmlsdGVyIHRyYW5zaXRpb24gZW5kIGV2ZW50cywgYmVjYXVzZSB0aGV5IG1pZ2h0IGJ1YmJsZSBmcm9tIHNob3J0ZXIgdHJhbnNpdGlvbnNcbiAgICAgICAgICAvLyBvbiBpbm5lciBET00gZWxlbWVudHMuIFdlJ3JlIG9ubHkgaW50ZXJlc3RlZCBpbiB0aGUgdHJhbnNpdGlvbiBvbiB0aGUgJ2VsZW1lbnQnIGl0c2VsZi5cbiAgICAgICAgICBjb25zdCB0cmFuc2l0aW9uRW5kJCA9XG4gICAgICAgICAgICAgIGZyb21FdmVudChlbGVtZW50LCAndHJhbnNpdGlvbmVuZCcpLnBpcGUodGFrZVVudGlsKHN0b3AkKSwgZmlsdGVyKCh7dGFyZ2V0fSkgPT4gdGFyZ2V0ID09PSBlbGVtZW50KSk7XG4gICAgICAgICAgY29uc3QgdGltZXIkID0gdGltZXIodHJhbnNpdGlvbkR1cmF0aW9uTXMgKyB0cmFuc2l0aW9uVGltZXJEZWxheU1zKS5waXBlKHRha2VVbnRpbChzdG9wJCkpO1xuXG4gICAgICAgICAgcmFjZSh0aW1lciQsIHRyYW5zaXRpb25FbmQkKS5waXBlKHRha2VVbnRpbChzdG9wJCkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICBydW5uaW5nVHJhbnNpdGlvbnMuZGVsZXRlKGVsZW1lbnQpO1xuICAgICAgICAgICAgZW5kRm4oKTtcbiAgICAgICAgICAgIHRyYW5zaXRpb24kLm5leHQoKTtcbiAgICAgICAgICAgIHRyYW5zaXRpb24kLmNvbXBsZXRlKCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm4gdHJhbnNpdGlvbiQuYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIH07XG4iXX0=